# 一、测试说明
这是一个对于STEP应用层协议的测试计划 分为
  - A 功能性与正确性 
  - B 鲁棒性 / 错误处理 
  - C 应用层性能测试
其中B 部分由于时间精力的限制暂缓测试。每个小项对应一个测试脚本。
# 二、测试环境
- 【首选】采用在 Ubuntu 上用 VirtualBox 创建 2–4 台轻量 Linux VM（Host-only 或 Internal network）可以完全控制网络拓扑、延迟和带宽，适合服务器性能弱且需要多个节点的场景。配合 tcpdump/Packet sniffer 可抓到清晰数据包。
- 同子网 Windows 也可以：若在真实局域网测试，用一台 Windows 做 server（或把服务运行在 Windows 上），其他 Windows 做 client，全部连接到同一热点或交换机即可。只要能排除外部流量干扰、并记录 baseline，结果是有效的。
# 三、测试清单 —— 每个测试对应的“脚本（步骤）”

> 说明：每项下的 “测试脚本” 均为顺序步骤（你可以把它们直接写成自动化脚本的步骤）。“收集项”列出要保存的文件/记录；“判定”给出 PASS/FAIL 简单规则。

---

## A. 功能性与正确性（必须保留）

### A1 — 基线：单客户端标准文件上传（基本功能）

* **目的**：确认协议基础流程（Token、申请上传、分块、完成、MD5 校验）完全正确。
* **输入**：文件 10 MB（或课程要求的常用大小）。
* **步骤**：

  1. 在 server 启动服务并清空测试目录；记录 server 时间、可用磁盘空间。
  2. 在 client 运行上传命令并记录开始时间。
  3. 观察并记录客户端日志（Token、每块上传确认、最终完成信息）。
  4. 等待上传结束，记录结束时间。
  5. 在 client 和 server 分别计算文件 MD5：`md5(client_file)` 与 `md5(server_stored_file)`。
* **收集项**：client log、server log、start/end 时间、两端 MD5、文件大小、资源（cpu%、mem）。
* **判定**：MD5 相同且 client 端显示完成 → PASS；否则 FAIL。

### A2 — 0 字节 / 1 字节 文件上传（极小文件）

* **目的**：确认极小文件的处理（0B 是否允许/1B edge-case）。
* **输入**：文件 0B，文件 1B。
* **步骤**：同 A1，分别上传 0B 与 1B。
* **收集项**：同 A1。
* **判定**：服务端能正确返回成功或明确报错（若作业不允许 0B 则需明确报错信息），并且行为与规范一致 → PASS。

### A3 — 文件大小非 block_size 倍数（尾块处理）

* **目的**：测试最后一块小于 block_size 时是否正确处理。
* **输入**：比如 block_size = 64KB，文件大小 = 10MB + 13KB（非整除情况）。
* **步骤**：同 A1；注意抓取客户端对最后一个块长度的日志。
* **收集项**：最后一块长度日志、MD5。
* **判定**：最后块被接收且整体 MD5 正确 → PASS。

### A4 — 重复上传（同文件名/同内容） / 覆盖策略

* **目的**：定义并验证对重复上传的服务器端策略（覆盖、拒绝或版本化）。
* **输入**：同一文件上传两次（立即连续或稍间隔）。
* **步骤**：

  1. 上传一次（记录完成）。
  2. 再次上传（记录 server 的返回）。
* **收集项**：两次的 server 返回值、文件存储位置、MD5（两次应该相同或 server 表示冲突）。
* **判定**：行为与协议/作业要求一致（例如若要求覆盖则最终文件 MD5 应相同） → PASS。

### A5 — 错误凭据（Token/Key 错误）

* **目的**：确保客户端/服务器在认证或 key 错误时返回清晰错误，且不会产生未定义行为。
* **输入**：修改 client 发送的 token（或使用无效 key）。
* **步骤**：向 server 发起上传请求但发送错误 token，观察返回。
* **收集项**：server error response、client log。
* **判定**：服务器应返回明确的错误码/消息，且不写入文件 → PASS。

### A6 — 错误块内容（模拟传输破坏）

* **目的**：模拟单个块 data 错误（例如 client 意外篡改发送数据或 server 校验失败时的响应）。
* **输入**：上传过程在某块被故意篡改或客户端模拟 CRC/MD5 校验失败。
* **步骤**：

  1. 在一个中间块发送前，修改该块的内容（或让 client 捏造不一致的校验值）。
  2. 观察 server 如何回应（拒绝该块、要求重传等）。
* **收集项**：server log、client log。
* **判定**：如果 server 能检测到并合理响应（返回失败码） → PASS。若 server 接受并导致最终 MD5 错误 → FAIL。

---

## B. 鲁棒性 / 错误处理（关键项，优先保留几个典型场景）

### B1 — 服务端临时重启（服务重启场景）

* **目的**：观察在 server 在上传过程中重启时客户端的行为（客户端应获得错误并能重新开始/重试或报错）。
* **步骤**：

  1. 启动上传（中途等待到某中间块）。
  2. 从另一终端重启 server（service restart 或 kill + start）。
  3. 观察 client 端是否检测到异常、是否重试（若协议不支持断点续传，则预期为失败并给出错误）。
* **收集项**：client log、server log（包含 restart 时间）、是否生成临时文件。
* **判定**：客户端须能检测到失败并给出合适提示；server 在重启后状态应一致（无半成文件残留）→ PASS/FAIL 根据协议预期。

### B2 — 并发冲突（两个客户端同时上传同名文件）

* **目的**：检验并发上传同一目标（同名或同 key）时 server 的一致性/冲突处理。
* **输入**：两个客户端同时上传文件（相同或不同内容）。
* **步骤**：

  1. 在两台 client 同时开始上传同名文件。
  2. 记录两侧日志与 server 的最终状态（哪个成功、是否覆盖或产生冲突）。
* **收集项**：client1 log、client2 log、server 最终文件与可能生成的冲突信息。
* **判定**：行为与协议定义一致（例如：server 拒绝第二个或将其覆盖或产生不同版本）→ PASS。

### B3 — 非法/畸形请求（协议解析鲁棒）

* **目的**：验证 server 在接收到畸形/缺字段的上传请求时不会崩溃并能返回清晰错误。
* **步骤**：用构造的请求（缺少必要 header、字段格式错误）向 server 提交。
* **收集项**：server error log、HTTP status code 或协议应用层错误码。
* **判定**：server 返回 4xx/5xx 类型的错误并无崩溃 → PASS。

---

## C. 精简的应用层性能测试（C-min：只测 goodput/延时/资源，不深入 TCP 内部）

> 说明：这些测试保留最少必要项以证明协议性能随参数变化的趋势。

### C1 — 不同文件大小的上传耗时（扩展性）

* **目的**：测量上传耗时随着文件大小（1 KB、100 KB、1 MB、10 MB、50 MB、100MB、500MB）变化的关系。
* **步骤**：

  1. 在相同网络条件下（同一子网或同一 VirtualBox internal net），依次上传不同大小文件（每个大小重复 3–5 次）。
  2. 记录 start/end 时间，计算平均耗时与标准差。
* **收集项**：每次耗时、goodput (MB/s)、client/server CPU 峰值、MD5。
* **判定**：所有上传成功且 goodput 呈合理增长/稳定（若出现极端慢或失败需进一步分析）→ PASS。

### C2 — 不同 block_size 的影响（应用层参数敏感性）

* **目的**：测试几个常见 block_size（4KB、64KB、256KB、1MB）下同一文件（如 10MB）的上传时间与资源开销。
* **步骤**：与 C1 类似，但固定文件大小，改变 block_size 参数，重复多次。
* **收集项**：耗时、goodput、每块发送次数统计（client 日志）、CPU。
* **判定**：记录并比较不同 block_size 的平均 goodput 与方差，找出在当前环境下“良好区间”（报告中给出结论）。

### C3 — 并发客户端（低并发，最多 4 个）对应用吞吐的影响

* **目的**：在可控范围内测试并发时应用层总吞吐与单客户端吞吐变化（验证协议在并发下是否合理）。
* **步骤**：

  1. 使用 1、2、4 个 client（在不同主机或多个进程）同时上传各自的 10MB 文件。
  2. 记录每个 client 的耗时与 goodput，以及 server 端资源占用（CPU/IO）。
* **收集项**：每个 client 的 goodput、server CPU、IO 使用率、成功率。
* **判定**：分析并发下的公平性与总吞吐是否合乎预期；若出现明显崩溃或失败 → FAIL。

### C4 — 恶劣网络条件下的应用层成功率（轻量）

* **目的**：在受控的轻度恶劣条件下（限制带宽、增加延迟或丢包）测应用层成功率与耗时（但不深入 TCP）。
* **步骤**：

  1. 在 VirtualBox 自建网络或在 Ubuntu（有 root 权限）使用 `tc` 对 server（或 client）端口临时注入：

     * 场景 a：限制带宽到 1 Mbps
     * 场景 b：增加 RTT 到 200 ms
     * 场景 c：丢包 1%
  2. 对每场景运行一次 10MB 上传（重复 3 次），记录成功率和耗时。
* **收集项**：耗时、成功/失败次数、md5。
* **判定**：记录临界条件（比如在 1% 丢包或 200 ms 时成功率大于 90% 可视为“可容忍”），否则需在报告里指出需要协议改进。

> 可在 VirtualBox 的 Host-only 或 NAT 网络中进行相同 `tc` 注入实验以获得可重复结果。

---